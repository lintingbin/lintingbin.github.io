---
title: 'efficiency_guide:七个Erlang性能的误区'
date: 2017-10-14 12:35:14
tags: Erlang
categories: Erlang Efficiency Guide
---
> 这些内容是有些是由于Erlang版本变化做的一些优化，和之前的有些要点有些出入，快速的扫一下即可

#### 尾递归总是比普通递归来的快
这个说法在R12B之前是真的。在R7B之前更是如此。但是现在普通递归通常使用与尾递归相同的内存量，通常不可能预测尾递归或身体递归版本是否更快。因此，使用使代码更清洁的版本就可以了（通常是普通递归的版本）。但是死循环还是要使用尾递归，防止内存耗尽。
#### "++" 操作总是不好的
如果是这样[H] ++ Tail 使用 "++" 操作的话，没有什么不好的，编译器会自动把该操作转换成[H| Tail]。
#### 字符串操作很慢
如果不正确地使用字符串，字符串操作速度可能很慢。在Erlang中，需要更多地思考如何使用字符串并选择适当的字符表示。如果使用正则表达式，请使用STDLIB中的re模块，而不是过时的regexp模块。
#### 修复Dets文件非常慢
Dets文件的修复时间与文件中的记录数成正比，虽然Dets文件修复以前很慢，但是Dets的实现已被大量改写和改进。
#### BEAM是一个基于堆栈的字节码虚拟机（因此比较慢）
BEAM是一个基于寄存器的虚拟机。它有1024个虚拟寄存器，用于保存临时值，并在调用函数时传递参数。需要在函数调用中使用的变量将保存到堆栈中。
BEAM是一个线程代码解释器。每个指令是直接指向可执行C代码的字，使得指令调度非常快。
#### 当变量不被使用时，使用“_”来加快程序速度
这个在R6B版本之前是这样的，但是在这个版本之后，编译器能够自动识别不使用的变量，所以用不用“_”都一样。
#### NIF总是能使你的程序更快
将Erlang代码重写为NIF以使其更快，应该被视为最后的手段。使用NIF肯定有风险，但是不能保证程序能更快。在每个NIF调用中进行太多的工作会降低VM的响应能力。做太少的工作可能意味着NIF中更快处理的优势被调用NIF并检查参数的开销所抵消了。所以在写NIF之前，请务必阅读 [Long-running NIFs](http://erlang.org/doc/man/erl_nif.html#lengthy_work) 。
